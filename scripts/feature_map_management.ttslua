--These functions store basic information about the features on the tiles, along with a feature map in order to arbitrarily find those feastures
--This new system is intended to replace the old method of using recusion to traverse the tiles, which should save time when the AI is making decisions
--recursion is still needed when removing tiles, but this should be a rare event

function addTile(xIndex, zIndex, tile, rotation, temp)
    --note: if this function is called with temp=true, you must separately clear tileGrid[xIndex][zIndex] to nil once you are finished
    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
    tileGrid[xIndex][zIndex] = {}
    tileGrid[xIndex][zIndex].tile_guid = tile.getGUID()
    tileGrid[xIndex][zIndex].rotation = rotation
    tileGrid[xIndex][zIndex].featureMap = {}
    if startingTile_GUID == nil and tile.getVar('isStartingPiece') and not temp then
        startingTile_GUID = tile.getGUID()
        linkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}
        validTileLocations = {}
        tileConnectionOdds = {}
        featureIndex = 0
        featureList = {}
    end
    if startingRiverTile_GUID == nil and tile.getVar('isStartingPiece') and not temp then
        startingRiverTile_GUID = tile.getGUID()
    end
    if temp then --do not modify the original data. If anything is modified, make a copy of it before modifying
        tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}
        tempValidTileLocations = {}
        tempTileConnectionOdds = {}
        tempFeatureIndex = featureIndex
        tempFeatureList = {}
        tempJoinedFeature = {}
    else
        --if the newest tile is at the edge of the play area, then shift it if there is room
        --https://stackoverflow.com/a/1252776
        local next = next
        if xIndex == MIN_X and (tileGrid[MAX_X] == nil or next(tileGrid[MAX_X]) == nil) then
            shiftPlayArea(1, 0)
            xIndex = xIndex + 1
        end
        if xIndex == MAX_X and (tileGrid[MIN_X] == nil or next(tileGrid[MIN_X]) == nil) then
            shiftPlayArea(-1, 0)
            xIndex = xIndex - 1
        end
        if zIndex == MIN_Z then
            local atEdge = false
            for _, tileColumn in pairs(tileGrid) do
                if tileColumn[MAX_Z] ~= nil then
                    atEdge = true
                    break
                end
            end
            if not atEdge then
                shiftPlayArea(0, 1)
                zIndex = zIndex + 1
            end
        end
        if zIndex == MAX_Z then
            local atEdge = false
            for _, tileColumn in pairs(tileGrid) do
                if tileColumn[MIN_Z] ~= nil then
                    atEdge = true
                    break
                end
            end
            if not atEdge then
                shiftPlayArea(0, -1)
                zIndex = zIndex - 1
            end
        end
        if tile.getGUID() == finalTile_GUID then
            finalTile_GUID = nil
        end
        if tile.getGUID() == finalRiverTile_GUID then
            finalRiverTile_GUID = nil
        end
        if tile.getGUID() == forkTile_GUID then
            forkTile_GUID = nil
        end
        if tile.getGUID() == springTile_GUID then
            springTile_GUID = nil
        end
        if tile.getGUID() == lakeTile_GUID then
            lakeTile_GUID = nil
        end

        tileGrid[xIndex][zIndex].ignoredFeatures = tile.getTable('ignoredFeatures')

        lastPlacedTileX = xIndex
        lastPlacedTileZ = zIndex
        if lastPlacedPlayerTiles[activePlayers[currentPlayer]] ~= nil then
            local coordinates = lastPlacedPlayerTiles[activePlayers[currentPlayer]]
            if tileGridOccupied(coordinates.x, coordinates.z) then
                local tile = getObjectFromGUID(tileGrid[coordinates.x][coordinates.z].tile_guid)
                tile.highlightOff()
            end
        end
        lastPlacedPlayerTiles[activePlayers[currentPlayer]] = {x=xIndex, z=zIndex}
    end
    local targetLinkedFeatures
    local targetFeatureList
    if temp then
        targetLinkedFeatures = tempLinkedFeatures
        targetFeatureList = tempFeatureList
    else
        targetLinkedFeatures = linkedFeatures
        targetFeatureList = featureList
    end
    local visitedFeatures = {}
    local specialFeatures = tile.getTable('specialFeatures')
    local numSpecialFeatures = 0
    local invalidatedFeatureCoordinates = {}
    local alreadyAddedFeatures = {} --to handle a special case where the same feature can be merged by multiple separate features on the tile, in which case numTiles should only be increased once
    if specialFeatures ~= nil then numSpecialFeatures = #specialFeatures end
    local numFeatures = 12 + numSpecialFeatures
    for position=1, numFeatures do
        local nameOfFeature = getTileFeatureName(tile, position)
        if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' or nameOfFeature == 'Abbey') and not (position > 12 and specialFeatures[position-12][3] == nil) and not visitedFeatures[position] then
            local featurePositions = {}
            local linkedSpecialFeatures = {}
            local connectedFeatures = {}
            local numOpenings = 0
            local featureOpeningCoords = {}
            local links = nil

            if position < 5 then
                links = getLinkedQuadrants(tile)
            elseif position < 13 then
                links = tile.getTable('linkedOctants')
            end
            local visitedPosition = false
            while not visitedPosition do
                if links ~= nil then
                    for _, link in ipairs(links) do
                        --HACK: Because quadrants and octants can't be linked, Abbeys create a scenario where they get different feature numbers.
                        --The least hacky way I could fix it (without having to redo huge chunks of code) was as follows, in addition to linking all 12 positions to the 13th on the tiles...
                        if nameOfFeature == 'Abbey' and position < 13 then
                            link = {1,2,3,4,5,6,7,8,9,10,11,12,13}
                        end
                        if table.contains(link, position) then
                            visitedPosition = true
                            for _, nestedPosition in ipairs(link) do
                                featurePositions[nestedPosition] = true
                                if nestedPosition < 13 then
                                    local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(xIndex, zIndex, nestedPosition, rotation)
                                    if tileGridOccupied(connectedX, connectedZ) and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] ~= nil then
                                        if nameOfFeature ~= 'Abbey' then
                                            numOpenings = numOpenings - 1
                                            if not table.contains(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]) then
                                                table.insert(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition])
                                            end
                                        else
                                            if temp and tempFeatureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]] == nil then
                                                tempFeatureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]] = {}
                                            end
                                            targetFeatureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]].numOpenings = featureList[tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition]].numOpenings - 1
                                        end
                                    elseif nameOfFeature ~= 'Abbey' then
                                        numOpenings = numOpenings + 1
                                        featureOpeningCoords[connectedX .. "-" .. connectedZ] = true
                                    end
                                end
                            end
                        end
                    end
                end
                if not visitedPosition then
                    links = {{position}}
                end
            end
            if specialFeatures ~= nil then
                for i, feature in ipairs(specialFeatures) do
                    if feature[2] ~= nil then
                        if table.contains(feature[2], position) then
                            if feature[3] ~= nil then
                                featurePositions[i+12] = true
                            elseif feature[1] ~= 'City-Field' and feature[1] ~= 'Road Intersection' then
                                --Make a list of special features that should be linked (City-Field and Road Intersection have a separate system stored in linkedFeatures. This is done later)
                                table.insert(linkedSpecialFeatures, feature[1])
                            end
                        end
                    end
                end
            end

            local newFeatureIndex
            if #connectedFeatures > 0 then --this feature joined with an existing one, so we'll just add to that
                newFeatureIndex = connectedFeatures[1]

                if temp then
                    if tempFeatureList[newFeatureIndex] == nil then
                        tempFeatureList[newFeatureIndex] = {}
                    end
                    tempFeatureList[newFeatureIndex].specialFeatures = table.shallow_copy(featureList[newFeatureIndex].specialFeatures)
                    tempFeatureList[newFeatureIndex].nameOfFeature = featureList[newFeatureIndex].nameOfFeature
                end

                for _, specialFeature in ipairs(linkedSpecialFeatures) do
                    table.insert(targetFeatureList[newFeatureIndex].specialFeatures, specialFeature)
                end
                targetFeatureList[newFeatureIndex].numOpenings = featureList[newFeatureIndex].numOpenings + numOpenings
                for key, opening in pairs(featureList[newFeatureIndex].openingCoords) do
                    if key ~= xIndex .. "-" .. zIndex then
                        featureOpeningCoords[key] = true
                    end
                end
                targetFeatureList[newFeatureIndex].openingCoords = featureOpeningCoords
                if nameOfFeature == 'Field' then
                    targetFeatureList[newFeatureIndex].numTiles = 0
                elseif alreadyAddedFeatures[newFeatureIndex] ~= true then
                    targetFeatureList[newFeatureIndex].numTiles = featureList[newFeatureIndex].numTiles + 1
                end

                if temp then
                    if linkedFeatures['City-Field'][newFeatureIndex] ~= nil then
                        tempLinkedFeatures['City-Field'][newFeatureIndex] = table.shallow_copy(linkedFeatures['City-Field'][newFeatureIndex])
                    end
                    if linkedFeatures['Road Intersection'][newFeatureIndex] ~= nil then
                        tempLinkedFeatures['Road Intersection'][newFeatureIndex] = table.shallow_copy(linkedFeatures['Road Intersection'][newFeatureIndex])
                    end
                end

                if #connectedFeatures > 1 then --this feature merged with more than one feature, so we'll need to do a bit more work to merge them
                    local visitedTiles = {}
                    for i, connectedFeatureNum in ipairs(connectedFeatures) do
                        --if this feature has already been connected to another, then this feature should connect to that one instead
                        if temp and tempJoinedFeature[connectedFeatureNum] ~= nil then
                            newConnectedFeatureNum = newFeatureIndex
                            newFeatureIndex = tempJoinedFeature[connectedFeatureNum]
                            connectedFeatureNum = newConnectedFeatureNum
                        end
                        for linkType, originFeatures in pairs(linkedFeatures) do
                            if linkedFeatures[linkType][connectedFeatureNum] ~= nil then
                                for destinationFeature, _ in pairs(linkedFeatures[linkType][connectedFeatureNum]) do
                                    if destinationFeature ~= newFeatureIndex then --don't copy a reference to itself
                                        if linkedFeatures[linkType][newFeatureIndex] == nil then
                                            targetLinkedFeatures[linkType][newFeatureIndex] = {}
                                        end
                                        targetLinkedFeatures[linkType][newFeatureIndex][destinationFeature] = true
                                    end
                                end
                            end
                            for originFeature, _ in pairs(originFeatures) do
                                if originFeature ~= newFeatureIndex then --don't copy a reference to itself
                                    if linkedFeatures[linkType][originFeature][connectedFeatureNum] ~= nil then
                                        if temp then
                                            --if a link needs to be changed then it needs to be copied from the original table if it exists
                                            if tempLinkedFeatures[linkType][originFeature] == nil then
                                                if linkedFeatures[linkType][originFeature] ~= nil then
                                                    tempLinkedFeatures[linkType][originFeature] = table.shallow_copy(linkedFeatures[linkType][originFeature])
                                                else
                                                    tempLinkedFeatures[linkType][originFeature] = {}
                                                end
                                            end
                                        else
                                            if linkedFeatures[linkType][originFeature] == nil then
                                                linkedFeatures[linkType][originFeature] = {}
                                            end
                                        end
                                        targetLinkedFeatures[linkType][originFeature][newFeatureIndex] = true
                                    end
                                end
                            end
                        end
                        if i == 1 then
                            if nameOfFeature ~= 'Field' then
                                for nestedX, featureColumn in pairs(tileGrid) do
                                    for nestedZ, tileData in pairs(featureColumn) do
                                        for nestedFeaturePosition, featureNum in pairs(tileData.featureMap) do
                                            if featureNum == connectedFeatureNum then
                                                if visitedTiles[nestedX] == nil then visitedTiles[nestedX] = {} end
                                                visitedTiles[nestedX][nestedZ] = true
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        else --if 2 or more features have been merged to one, we should combine all special features, add the numOpenings to each other, and recalculate numTiles
                            for _, specialFeature in ipairs(featureList[connectedFeatureNum].specialFeatures) do
                                table.insert(targetFeatureList[newFeatureIndex].specialFeatures, specialFeature)
                            end
                            targetFeatureList[newFeatureIndex].numOpenings = targetFeatureList[newFeatureIndex].numOpenings + featureList[connectedFeatureNum].numOpenings
                            for openingCoord, _ in pairs(featureList[connectedFeatureNum].openingCoords) do
                                if openingCoord ~= xIndex .. "-" .. zIndex then
                                    targetFeatureList[newFeatureIndex].openingCoords[openingCoord] = true
                                    invalidatedFeatureCoordinates[openingCoord] = true
                                end
                            end
                            if temp then
                                tempJoinedFeature[connectedFeatureNum] = newFeatureIndex
                            end
                            for nestedX, featureColumn in pairs(tileGrid) do
                                for nestedZ, tileData in pairs(featureColumn) do
                                    for nestedFeature, featureNum in pairs(tileData.featureMap) do
                                        if featureNum == connectedFeatureNum then
                                            --print("featureNum " .. newFeatureIndex .. " on x:" .. nestedX .. " y:" .. nestedZ .. " assigned to position " .. nestedFeature)
                                            if not temp then
                                                tileGrid[nestedX][nestedZ].featureMap[nestedFeature] = newFeatureIndex
                                            end
                                            if nameOfFeature ~= 'Field' then
                                                if visitedTiles[nestedX] == nil then visitedTiles[nestedX] = {} end
                                                if not visitedTiles[nestedX][nestedZ] then
                                                    --since there's a chance that multiple features occupy the same tile, we can't trust the numTiles property of this feature and must recount
                                                    targetFeatureList[newFeatureIndex].numTiles = targetFeatureList[newFeatureIndex].numTiles + 1
                                                    visitedTiles[nestedX][nestedZ] = true
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if not temp then
                                featureList[connectedFeatureNum] = nil
                                for linkType, originFeatures in pairs(linkedFeatures) do
                                    for origin, _ in pairs(originFeatures) do
                                        linkedFeatures[linkType][origin][connectedFeatureNum] = nil
                                    end
                                    linkedFeatures[linkType][connectedFeatureNum] = nil
                                end
                            end
                        end
                    end
                end
                alreadyAddedFeatures[newFeatureIndex] = true
            else --this feature didn't merge with any existing one, so it is brand new and should be initialized and given a new feature number
                if temp then
                    tempFeatureIndex = tempFeatureIndex + 1
                    newFeatureIndex = tostring(tempFeatureIndex)
                else
                    featureIndex = featureIndex + 1
                    newFeatureIndex = tostring(featureIndex)
                end
                targetFeatureList[newFeatureIndex] = {}
                targetFeatureList[newFeatureIndex].nameOfFeature = nameOfFeature
                targetFeatureList[newFeatureIndex].specialFeatures = linkedSpecialFeatures
                targetFeatureList[newFeatureIndex].numOpenings = numOpenings
                targetFeatureList[newFeatureIndex].openingCoords = featureOpeningCoords
                if table.contains(PROXIMITY_FEATURES, nameOfFeature) then
                    targetFeatureList[newFeatureIndex].featureLocation = {x=xIndex, z=zIndex}
                    targetFeatureList[newFeatureIndex].numTiles = 1
                    for i, offset in ipairs(DIAGONAL_DELTA) do
                        local neighborX = xIndex + offset.x
                        local neighborZ = zIndex + offset.z
                        if tileGridOccupied(neighborX, neighborZ) then
                            targetFeatureList[newFeatureIndex].numTiles = targetFeatureList[newFeatureIndex].numTiles + 1
                            local neighborTile = getObjectFromGUID(tileGrid[neighborX][neighborZ].tile_guid)
                            local neighborRotation = tileGrid[neighborX][neighborZ].rotation
                            local neighborSpecialFeatures = neighborTile.getTable('specialFeatures')
                            if neighborSpecialFeatures ~= nil then
                                for _, neighborSpecialFeature in ipairs(neighborSpecialFeatures) do
                                    if neighborSpecialFeature[1] == 'Vineyard' then
                                        table.insert(linkedSpecialFeatures, neighborSpecialFeature[1])
                                    end
                                end
                            end
                        else
                            targetFeatureList[newFeatureIndex].openingCoords[neighborX .. "-" .. neighborZ] = true
                        end
                    end
                    targetFeatureList[newFeatureIndex].numOpenings = 9 - targetFeatureList[newFeatureIndex].numTiles
                elseif nameOfFeature ~= 'Field' then
                    targetFeatureList[newFeatureIndex].numTiles = 1
                else
                    targetFeatureList[newFeatureIndex].numTiles = 0
                end
            end
            for nestedTilePosition, featurePosition in pairs(featurePositions) do
                local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, rotation)
                tileGrid[xIndex][zIndex].featureMap[nestedFeatureMapPosition] = newFeatureIndex
                visitedFeatures[nestedTilePosition] = true
            end
        end
    end

    local addToProximityFeatures = {}
    if specialFeatures ~= nil then
        for specialFeatureNum, feature in ipairs(specialFeatures) do
            local nameOfFeature = feature[1]
            if feature[3] ~= nil then --if this specialFeature has a location, add it to tileGrid
                if tileGrid[xIndex][zIndex].specialFeatureLocations == nil then tileGrid[xIndex][zIndex].specialFeatureLocations = {} end
                local x, z = rotateCoordinates(feature[3][1], feature[3][2], (TILE_STANDARD_ROTATION - 1 - rotation) % 4 + 1)
                tileGrid[xIndex][zIndex].specialFeatureLocations[specialFeatureNum] = {x=x, z=z, nameOfFeature=nameOfFeature}
            end

            if nameOfFeature == 'City-Field' or nameOfFeature == 'Road Intersection' then --if this specialFeature is a "linked feature", add it to the linkedFeatures map
                local nestedLinkedFeatures = {}
                for _, nestedTilePosition in ipairs(feature[2]) do
                    local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, rotation)
                    local featureNum = tileGrid[xIndex][zIndex].featureMap[nestedFeatureMapPosition]
                    if not table.contains(nestedLinkedFeatures, featureNum) then
                        table.insert(nestedLinkedFeatures, featureNum)
                    end
                end
                for _, nestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                    if targetLinkedFeatures[nameOfFeature][nestedLinkedFeature] == nil then
                        targetLinkedFeatures[nameOfFeature][nestedLinkedFeature] = {}
                    end
                    for _, nestedNestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                        if nestedLinkedFeature ~= nestedNestedLinkedFeature and (nameOfFeature == 'Road Intersection' or targetFeatureList[nestedNestedLinkedFeature].nameOfFeature ~= targetFeatureList[nestedLinkedFeature].nameOfFeature) then
                            targetLinkedFeatures[nameOfFeature][nestedLinkedFeature][nestedNestedLinkedFeature] = true
                        end
                    end
                end
            elseif nameOfFeature == 'Vineyard' then --if this tile contains specialFeatures relevant to neighboring tiles, add them to a list (there should only ever be one proximity feature per tile, but I'm leaving it open to shenanigan fan tiles)
                table.insert(addToProximityFeatures, feature[1])
            elseif (not temp and table.contains(TILE_FEATURES, nameOfFeature)) --if this tile contains tileFeatures, add them to a list
                or nameOfFeature == 'Abbey' or nameOfFeature == 'Vineyard' then --HACK: I'm worried that checking the whole TILE_FEATURES for each feature will have a performance hit. For AI, only Abbey and Vineyard is needed.
                    if tileGrid[xIndex][zIndex].tileFeatures == nil then tileGrid[xIndex][zIndex].tileFeatures = {} end
                    table.insert(tileGrid[xIndex][zIndex].tileFeatures, nameOfFeature)
            end
        end
    end

    --if there is a nearby proximity feature, make sure to count this tile. Also add any previously found addToProximityFeatures
    for _, offset in ipairs(DIAGONAL_DELTA) do
        local neighborX = xIndex + offset.x
        local neighborZ = zIndex + offset.z
        if tileGridOccupied(neighborX, neighborZ) then
            for neighborPositionNum, neighborFeatureNum in pairs(tileGrid[neighborX][neighborZ].featureMap) do
                if table.contains(PROXIMITY_FEATURES, featureList[neighborFeatureNum].nameOfFeature) and neighborPositionNum > 12 then --HACK: Only consider positions over 12 so that abbeys aren't counted multiple times
                    if temp then
                        tempFeatureList[neighborFeatureNum] = table.deep_copy(featureList[neighborFeatureNum])
                    end
                    targetFeatureList[neighborFeatureNum].numTiles = targetFeatureList[neighborFeatureNum].numTiles + 1
                    targetFeatureList[neighborFeatureNum].numOpenings = targetFeatureList[neighborFeatureNum].numOpenings - 1
                    targetFeatureList[neighborFeatureNum].openingCoords[xIndex .. "-" .. zIndex] = nil
                    for _, neighborSpecialFeature in ipairs(addToProximityFeatures) do
                        table.insert(targetFeatureList[neighborFeatureNum].specialFeatures, neighborSpecialFeature)
                    end
                end
            end
        end
    end

    AITileAdded(xIndex, zIndex, tile, rotation, temp)
    local targetTileConnectionOdds
    if temp then
        targetTileConnectionOdds = tempTileConnectionOdds
    else
        targetTileConnectionOdds = tileConnectionOdds
    end
    for openingCoord, _ in pairs(invalidatedFeatureCoordinates) do
        if openingCoord ~= xIndex .. "-" .. zIndex then
            local coord = string.split(openingCoord, "-")
            local x = tonumber(coord[1])
            local z = tonumber(coord[2])

            targetTileConnectionOdds[openingCoord] = AICalculateLocationOdds(openingCoord, x, z, xIndex, zIndex, temp)
        end
    end
end

function removeTile(xIndex, zIndex, removedTile)
    --if startingTile_GUID == tile.getGUID() then
    --    --TODO: find new tile to be the starting tile if one exists?
    --    startingTile_GUID = nil
    --end

    --the best way I could figure out to divide features that are split is to
    --remove all features on the tile from the entire featureMap,
    --then recursively re-add neighboring nil features
    for _, featureNum in pairs(tileGrid[xIndex][zIndex].featureMap) do
        --remove features
        featureList[featureNum] = nil
        for nestedX, featureColumn in pairs(tileGrid) do
            for nestedZ, tileData in pairs(featureColumn) do
                for nestedFeaturePosition, nestedFeatureNum in pairs(tileData.featureMap) do
                    if nestedFeatureNum == featureNum then
                        --remove from feature map
                        tileGrid[nestedX][nestedZ].featureMap[nestedFeaturePosition] = nil
                    end
                end
            end
        end

        --remove links
        for featureType, linkedSubFeatures in pairs(linkedFeatures) do
            linkedFeatures[featureType][featureNum] = nil
            for feature, _ in pairs(linkedSubFeatures) do
                if linkedFeatures[featureType][feature][featureNum] ~= nil then
                    linkedFeatures[featureType][feature][featureNum] = nil
                end
            end
        end
    end

    tileGrid[xIndex][zIndex] = nil

    if removedTile.getTable('sides')[1] ~= 'Abbey' then
        local tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}

        for position=1, 12 do
            local direction, sideDirection
            if position < 5 then
                direction = (3 + position + TILE_STANDARD_ROTATION) % 4 + 1
                sideDirection = direction
            else
                direction = (3 + position + TILE_STANDARD_ROTATION) % 8 + 5
                sideDirection = math.floor((direction - 3) / 2)
            end

            local connectedX = xIndex + SIDE_DELTA[sideDirection].x
            local connectedZ = zIndex + SIDE_DELTA[sideDirection].z

            if tileGridOccupied(connectedX, connectedZ) then
                local connectedTile = getObjectFromGUID(tileGrid[connectedX][connectedZ].tile_guid)
                local connectedTileRotation = tileGrid[connectedX][connectedZ].rotation
                local connectedTilePosition, featureMapPosition

                if position < 5 then
                    connectedTilePosition = (3 + position + TILE_STANDARD_ROTATION - connectedTileRotation + TILE_180_ROTATION) % 4 + 1
                    featureMapPosition = (3 + position + TILE_STANDARD_ROTATION - TILE_STANDARD_ROTATION + TILE_180_ROTATION) % 4 + 1
                else
                    connectedTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (connectedTileRotation * 2) - 4) % 8 + 5
                    featureMapPosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (TILE_STANDARD_ROTATION * 2) - 4) % 8 + 5
                end

                local nameOfFeature = getTileFeatureName(connectedTile, connectedTilePosition)
                if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River') and tileGrid[connectedX][connectedZ].featureMap[featureMapPosition] == nil then
                    --print(position .. ": checking x:" .. connectedX .. " z:" .. connectedZ .. " tilePosition:" .. connectedTilePosition .. " featureMapPosition:" .. featureMapPosition)
                    local numOpenings = getFeatureComponents(connectedX, connectedZ, connectedTilePosition, 2, true, nameOfFeature == 'City')

                    featureIndex = featureIndex + 1
                    newFeatureIndex = tostring(featureIndex)

                    featureList[newFeatureIndex] = {}
                    featureList[newFeatureIndex].nameOfFeature = nameOfFeature
                    local specialFeatures = {}
                    for i, specialFeature in ipairs(traversedSpecialFeatures) do
                        if specialFeature ~= 'Road Intersection' and specialFeature ~= 'City-Field' and specialFeature ~= 'Completed City' then
                            table.insert(specialFeatures, specialFeature)
                        end
                    end
                    featureList[newFeatureIndex].specialFeatures = traversedSpecialFeatures
                    featureList[newFeatureIndex].numOpenings = numOpenings
                    featureList[newFeatureIndex].openingCoords = traversedOpeningCoords
                    if nameOfFeature ~= 'Field' then
                        featureList[newFeatureIndex].numTiles = #traversedTileCoords
                    else
                        featureList[newFeatureIndex].numTiles = 0
                    end
                    if table.contains(PROXIMITY_FEATURES, nameOfFeature) then
                        featureList[newFeatureIndex].featureLocation = {x=connectedX, z=connectedZ}
                    end
                    tempLinkedFeatures['City-Field'][newFeatureIndex] = {}
                    tempLinkedFeatures['Road Intersection'][newFeatureIndex] = {}
                    for nestedXIndex, gridColumn in pairs(traversedFeaturePositions) do
                        for nestedZIndex, tileLocation in pairs(gridColumn) do
                            for nestedTilePosition, traversedFeaturePosition in pairs(tileLocation) do
                                local tile = getObjectFromGUID(tileGrid[nestedXIndex][nestedZIndex].tile_guid)
                                local rotation = tileGrid[nestedXIndex][nestedZIndex].rotation
                                --print("traversing " .. newFeatureIndex .. " to x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " pos: " .. nestedTilePosition)
                                if nestedTilePosition < 13 or tile.getTable('specialFeatures')[nestedTilePosition - 12][3] ~= nil then
                                    if nestedTilePosition > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' then
                                        local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, rotation)
                                        if traversedFeaturePosition == 1 then
                                            --print("assigning " .. newFeatureIndex .. " to x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " dir: " .. nestedFeatureMapPosition .. " pos: " .. nestedTilePosition)
                                            tileGrid[nestedXIndex][nestedZIndex].featureMap[nestedFeatureMapPosition] = newFeatureIndex
                                        elseif traversedFeaturePosition == 2 then
                                            if nameOfFeature == 'Field' then
                                                table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                            elseif nameOfFeature == 'City' then
                                                table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    for nestedXIndex, gridColumn in pairs(traversedGrid) do
                        for nestedZIndex, tileLocation in pairs(gridColumn) do
                            for nestedTilePosition, traversedPosition in pairs(tileLocation) do
                                local tile = getObjectFromGUID(tileGrid[nestedXIndex][nestedZIndex].tile_guid)
                                local rotation = tileGrid[nestedXIndex][nestedZIndex].rotation
                                if nestedTilePosition < 13 or tile.getTable('specialFeatures')[nestedTilePosition - 12][3] ~= nil then
                                    if nestedTilePosition > 4 or getTileFeatureName(tile, nestedTilePosition) == 'Road' or getTileFeatureName(tile, nestedTilePosition) == 'River' then
                                        local nestedFeatureMapPosition = tilePositionToFeatureMapPosition(nestedTilePosition, rotation)
                                        --print("traversed x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " dir: " .. nestedFeatureMapPosition .. " pos: " .. nestedTilePosition)
                                        if traversedFeaturePositions[nestedXIndex] == nil or traversedFeaturePositions[nestedXIndex][nestedZIndex] == nil or traversedFeaturePositions[nestedXIndex][nestedZIndex][nestedTilePosition] == nil or traversedFeaturePositions[nestedXIndex][nestedZIndex][nestedTilePosition] == 2 then
                                            if getTileFeatureName(tile, nestedTilePosition) == 'Field' then
                                                --table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                            elseif nameOfFeature == 'Field' then
                                                table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                            else
                                                table.insert(tempLinkedFeatures['Road Intersection'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedFeatureMapPosition})
                                                --print("added to Road Intersection for: " .. newFeatureIndex)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --re-add links
        for featureType, linkedFeatureCategory in pairs(tempLinkedFeatures) do
            for newFeatureIndex, categoryLinkedFeatures in pairs(linkedFeatureCategory) do
                for _, connectedFeatureDetails in ipairs(categoryLinkedFeatures) do
                    local connectedFeatureNum = getFeatureNumAt(connectedFeatureDetails.x, connectedFeatureDetails.z, connectedFeatureDetails.position)
                    if connectedFeatureNum == nil then
                        allErrorMessage("no feature found at: x: " .. connectedFeatureDetails.x .. " z: " .. connectedFeatureDetails.z .. " pos: " .. connectedFeatureDetails.position)
                    else
                        if connectedFeatureNum ~= newFeatureIndex then
                            if linkedFeatures[featureType][newFeatureIndex] == nil then
                                linkedFeatures[featureType][newFeatureIndex] = {}
                            end
                            --print("from location: x: " .. connectedFeatureDetails.x .. " z: " .. connectedFeatureDetails.z .. " pos: " .. connectedFeatureDetails.position)
                            --print("adding " .. featureType .. " link from " .. newFeatureIndex .. " to " .. connectedFeatureNum)
                            linkedFeatures[featureType][newFeatureIndex][connectedFeatureNum] = true
                            if linkedFeatures[featureType][connectedFeatureNum] == nil then
                                linkedFeatures[featureType][connectedFeatureNum] = {}
                            end
                            --print("adding " .. featureType .. " link from " .. connectedFeatureNum .. " to " .. newFeatureIndex)
                            linkedFeatures[featureType][connectedFeatureNum][newFeatureIndex] = true
                        end
                    end
                end
            end
        end
    end

    removeFromProximityFeatures = {}
    local specialFeatures = removedTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        --if this tile contains specialFeatures relevant to neighboring tiles, add them to a list (there should only ever be one, but I'm leaving it open to shenanigan fan tiles)
        for _, feature in ipairs(specialFeatures) do
            if feature[1] == 'Vineyard' then
                table.insert(removeFromProximityFeatures, feature[1])
            end
        end
    end

    for _, offset in ipairs(DIAGONAL_DELTA) do
        local neighborX = xIndex + offset.x
        local neighborZ = zIndex + offset.z
        if tileGridOccupied(neighborX, neighborZ) then
            for neighborPositionNum, neighborFeatureNum in pairs(tileGrid[neighborX][neighborZ].featureMap) do
                if table.contains(PROXIMITY_FEATURES, featureList[neighborFeatureNum].nameOfFeature) and neighborPositionNum > 12 then --HACK: Only consider positions over 12 so that abbeys aren't counted multiple times
                    featureList[neighborFeatureNum].numTiles = featureList[neighborFeatureNum].numTiles - 1
                    featureList[neighborFeatureNum].numOpenings = featureList[neighborFeatureNum].numOpenings + 1
                    featureList[neighborFeatureNum].openingCoords[xIndex .. "-" .. zIndex] = true
                    for _, neighborSpecialFeature in ipairs(removeFromProximityFeatures) do
                        for i, specialFeature in ipairs(featureList[neighborFeatureNum].specialFeatures) do
                            if neighborSpecialFeature == specialFeature then
                                table.remove(featureList[neighborFeatureNum].specialFeatures, i)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    AITileRemoved(xIndex, zIndex, removedTile)
end

--Wrapper method to add a hack for ferry titles
function getLinkedQuadrants(tile)
    if tile ~= nil then
        if tile.guid ~= nil then
            if ferriesLinkedQuadrants ~= nil then
                local t = ferriesLinkedQuadrants[tile.guid]
                if t ~= nil then
                    return t
                end
            end
        end
    end
    return tile.getTable('linkedQuadrants')
end

--Get the feature at the specified position
--Also takes into account features that have no "middle" (ie. fields and cities)
--Will return nil if there is still no feature at the given position (can happen if the feature is on the ignore list or both sides are not linked)
function getFeatureNumAt(xIndex, zIndex, position)
    local featureNum = tileGrid[xIndex][zIndex].featureMap[position]
    if featureNum == nil and position < 5 and tileGrid[xIndex][zIndex].featureMap[(position * 2) + 3] ~= nil and tileGrid[xIndex][zIndex].featureMap[(position * 2) + 3] == tileGrid[xIndex][zIndex].featureMap[(position * 2) + 4] then
        featureNum = tileGrid[xIndex][zIndex].featureMap[(position * 2) + 3]
    end
    return featureNum
end

--Will only work if tilePosition is < 13
--TILE_STANDARD_ROTATION can be used if tilePosition is actually a featureMapPosition TODO: Fix this later
function getConnectingFeatureMapPosition(xIndex, zIndex, tilePosition, tileRotation)
    local connectedFeatureMapPosition
    local connectedX, connectedZ
    if tilePosition < 5 then
        local direction = (3 + tilePosition + tileRotation) % 4 + 1
        local sideDirection = direction
        connectedX = xIndex + SIDE_DELTA[sideDirection].x
        connectedZ = zIndex + SIDE_DELTA[sideDirection].z
        connectedFeatureMapPosition = (3 + tilePosition + tileRotation - TILE_STANDARD_ROTATION + TILE_180_ROTATION) % 4 + 1
    else
        local direction = (3 + tilePosition + (tileRotation * 2)) % 8 + 5
        local sideDirection = math.floor((direction - 3) / 2)
        connectedX = xIndex + SIDE_DELTA[sideDirection].x
        connectedZ = zIndex + SIDE_DELTA[sideDirection].z
        connectedFeatureMapPosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (TILE_STANDARD_ROTATION * 2) - 4) % 8 + 5
    end
    return connectedFeatureMapPosition, connectedX, connectedZ
end

function tilePositionToFeatureMapPosition(tilePosition, tileRotation)
    if tilePosition < 5 then
        return (1 + tilePosition + tileRotation) % 4 + 1
    elseif tilePosition < 13 then
        return (tilePosition + (tileRotation * 2) - 1) % 8 + 5
    else
        return tilePosition
    end
end

function featureMapPositionToTilePosition(featureMapPosition, tileRotation)
    if featureMapPosition < 5 then
        return (5 + featureMapPosition - tileRotation) % 4 + 1
    elseif featureMapPosition < 13 then
        return (featureMapPosition - (tileRotation * 2) + 7) % 8 + 5
    else
        return featureMapPosition
    end
end

--This function will completely shift all objects on the table, along with the stored metadata, by the given deltas
function shiftPlayArea(delta_x, delta_z)
    allGameMessage(({"MESSAGE_PLAY_AREA_SHIFTING"}), NEUTRAL_COLOR)
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if obj.getGUID() ~= CONTROL_PANEL_GUID then
            local objPos = obj.getPosition()
            objPos.x = objPos.x + delta_x * TILE_SPACING
            objPos.z = objPos.z + delta_z * TILE_SPACING
            obj.setPosition(objPos)
        end
    end
    local start, last
    if delta_x ~= 0 then
        if delta_x < 0 then
            start = MIN_X
            last = MAX_X
        else
            start = MAX_X
            last = MIN_X
        end
        for x=start, last, -delta_x do
            if tileGrid[x] ~= nil then
                tileGrid[x + delta_x] = tileGrid[x]
                tileGrid[x] = nil
            end
        end
        for x=start, last, -delta_x do
            for openingCoord, _ in pairs(validTileLocations) do
                local coord = string.split(openingCoord, "-")
                local oldX = tonumber(coord[1])
                local oldZ = tonumber(coord[2])
                if (oldX == x) then
                    validTileLocations[oldX + delta_x .. "-" .. oldZ] = validTileLocations[oldX .. "-" .. oldZ]
                    validTileLocations[oldX .. "-" .. oldZ] = nil
                    tileConnectionOdds[oldX + delta_x .. "-" .. oldZ] = tileConnectionOdds[oldX .. "-" .. oldZ]
                    tileConnectionOdds[oldX .. "-" .. oldZ] = nil
                end
            end
            for _, feature in pairs(featureList) do
                for openingCoord, _ in pairs(feature.openingCoords) do
                    local coord = string.split(openingCoord, "-")
                    local oldX = tonumber(coord[1])
                    local oldZ = tonumber(coord[2])
                    if (oldX == x) then
                        feature.openingCoords[oldX + delta_x .. "-" .. oldZ] = true
                        feature.openingCoords[oldX .. "-" .. oldZ] = nil
                    end
                end
            end
        end
    end
    if delta_z ~= 0 then
        if delta_z < 0 then
            start = MIN_Z
            last = MAX_Z
        else
            start = MAX_Z
            last = MIN_Z
        end
        for x, _ in pairs(tileGrid) do
            for z=start, last, -delta_z do
                if tileGrid[x][z] ~= nil then
                    tileGrid[x][z + delta_z] = tileGrid[x][z]
                    tileGrid[x][z] = nil
                end
            end
        end
        for z=start, last, -delta_z do
            for openingCoord, _ in pairs(validTileLocations) do
                local coord = string.split(openingCoord, "-")
                local oldX = tonumber(coord[1])
                local oldZ = tonumber(coord[2])
                if (oldZ == z) then
                    validTileLocations[oldX .. "-" .. oldZ + delta_z] = validTileLocations[oldX .. "-" .. oldZ]
                    validTileLocations[oldX .. "-" .. oldZ] = nil
                    tileConnectionOdds[oldX .. "-" .. oldZ + delta_z] = tileConnectionOdds[oldX .. "-" .. oldZ]
                    tileConnectionOdds[oldX .. "-" .. oldZ] = nil
                end
            end
            for _, feature in pairs(featureList) do
                for openingCoord, _ in pairs(feature.openingCoords) do
                    local coord = string.split(openingCoord, "-")
                    local oldX = tonumber(coord[1])
                    local oldZ = tonumber(coord[2])
                    if (oldZ == z) then
                        feature.openingCoords[oldX .. "-" .. oldZ + delta_z] = true
                        feature.openingCoords[oldX .. "-" .. oldZ] = nil
                    end
                end
            end
        end
    end
end
